<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Frase finale 16</title>

  <style>
    * { box-sizing: border-box; }

    body{
      margin:0;
      background:white;
      font-family:sans-serif;
      display:flex;
      justify-content:center;
      align-items:center;
      min-height:100vh;
    }

    .wrapper{
      width:100%;
      max-width:900px;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:10px 0;
    }

    .screen{
      width:100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:15px;
    }

    canvas{
      border:none !important;
      touch-action:none;
      max-width:80vw;
      max-height:80vh;
      width:auto;
      height:auto;
      display:block;
    }

    /* ✅ BOTTONE (via di mezzo, stile unico) */
    .buttons-row{
      display:flex;
      justify-content:center;
      width:100%;
      max-width:380px;
      margin-top:14px;
    }

    button{
      width:100%;
      padding:11px 22px;
      font-size:17.5px;
      border-radius:9px;
      border:2px solid #333;
      background:#f2f2f2;
      cursor:pointer;
    }
  </style>
</head>

<body>

  <audio id="audioFrase">
    <source src="../audio/Frase finale 16.m4a" type="audio/mp4" />
  </audio>

  <div class="wrapper">
    <div class="screen">
      <canvas id="scene"></canvas>

      <!-- ✅ WRAP CORRETTO -->
      <div class="buttons-row">
        <button id="nextBtn">Prossima frase</button>
      </div>
    </div>
  </div>

<script>
  const canvas     = document.getElementById("scene");
  const ctx        = canvas.getContext("2d");
  const nextBtn    = document.getElementById("nextBtn");
  const audioFrase = document.getElementById("audioFrase");

  const WIDTH  = 800;
  const HEIGHT = 500;
  const ratio  = window.devicePixelRatio || 1;

  canvas.width  = WIDTH * ratio;
  canvas.height = HEIGHT * ratio;
  ctx.scale(ratio, ratio);

  // DIAGONALE:
  // cerchio giallo in basso a sinistra (attivo), cerchio rosso in alto a destra (passivo)
  // Frase: "Usa il cerchio giallo per spostare il cerchio rosso"
  const startYellow = { x: 240, y: 340, radius: 45 }; // basso-sinistra
  const startRed    = { x: 560, y: 160, radius: 45 }; // alto-destra

  const yellowToken = { x: startYellow.x, y: startYellow.y, radius: startYellow.radius };
  const redToken    = { x: startRed.x,    y: startRed.y,    radius: startRed.radius };

  let dragging = null;

  let collisionByYellow = false;
  let anyDrag = false;
  let draggedYellow = false;
  let draggedRed = false;

  /* ---------------- UTILI ---------------- */
  function distance(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

  function getCirclePolygon(c) {
    const sides = 16;
    const poly = [];
    for (let i = 0; i < sides; i++) {
      const a = (2 * Math.PI * i) / sides;
      poly.push({ x: c.x + c.radius * Math.cos(a), y: c.y + c.radius * Math.sin(a) });
    }
    return poly;
  }

  function getAxes(poly) {
    const axes = [];
    for (let i = 0; i < poly.length; i++) {
      const p1 = poly[i];
      const p2 = poly[(i + 1) % poly.length];
      const edge = { x: p2.x - p1.x, y: p2.y - p1.y };
      let normal = { x: -edge.y, y: edge.x };
      const len = Math.hypot(normal.x, normal.y);
      if (len !== 0) {
        normal.x /= len; normal.y /= len;
        axes.push(normal);
      }
    }
    return axes;
  }

  function projectPolygon(poly, axis) {
    let min = poly[0].x * axis.x + poly[0].y * axis.y;
    let max = min;
    for (let i = 1; i < poly.length; i++) {
      const p = poly[i];
      const proj = p.x * axis.x + p.y * axis.y;
      if (proj < min) min = proj;
      if (proj > max) max = proj;
    }
    return { min, max };
  }

  function getMTV(polyA, polyB, centerA, centerB) {
    const axes = [...getAxes(polyA), ...getAxes(polyB)];
    let smallestOverlap = Infinity;
    let smallestAxis = null;

    for (const axis of axes) {
      const projA = projectPolygon(polyA, axis);
      const projB = projectPolygon(polyB, axis);
      const overlap = Math.min(projA.max, projB.max) - Math.max(projA.min, projB.min);
      if (overlap <= 0) return null;
      if (overlap < smallestOverlap) {
        smallestOverlap = overlap;
        smallestAxis = axis;
      }
    }

    const dir = (centerB.x - centerA.x) * smallestAxis.x + (centerB.y - centerA.y) * smallestAxis.y;
    let axis = smallestAxis;
    if (dir < 0) axis = { x: -smallestAxis.x, y: -smallestAxis.y };

    return { x: axis.x * smallestOverlap, y: axis.y * smallestOverlap };
  }

  /* ---------------- DISEGNO ---------------- */
  function drawCircle(c, fill) {
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
    ctx.fillStyle = fill;
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1.5 / ratio;
    ctx.stroke();
  }

  function drawScene() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    drawCircle(redToken, "red");
    drawCircle(yellowToken, "yellow");
  }

  /* ----------- COLLISIONI ---------------- */
  // Giallo (attivo) spinge Rosso (passivo)
  function handleCollisionYellowPushRed() {
    const yellowPoly = getCirclePolygon(yellowToken);
    const redPoly    = getCirclePolygon(redToken);

    const mtv = getMTV(
      yellowPoly,
      redPoly,
      { x: yellowToken.x, y: yellowToken.y },
      { x: redToken.x,    y: redToken.y }
    );

    if (mtv) {
      redToken.x += mtv.x;
      redToken.y += mtv.y;
      collisionByYellow = true;
    }
  }

  // Se trascini il rosso, lui può spingere il giallo (ma sarà non corretto)
  function handleCollisionRedPushYellow() {
    const yellowPoly = getCirclePolygon(yellowToken);
    const redPoly    = getCirclePolygon(redToken);

    const mtv = getMTV(
      redPoly,
      yellowPoly,
      { x: redToken.x,    y: redToken.y },
      { x: yellowToken.x, y: yellowToken.y }
    );

    if (mtv) {
      yellowToken.x += mtv.x;
      yellowToken.y += mtv.y;
    }
  }

  /* ---------------- HIT TEST ---------------- */
  function insideCircle(x, y, c) { return distance(x, y, c.x, c.y) <= c.radius; }

  function getPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = WIDTH / rect.width;
    const scaleY = HEIGHT / rect.height;

    let clientX, clientY;
    if (evt.touches && evt.touches[0]) {
      clientX = evt.touches[0].clientX;
      clientY = evt.touches[0].clientY;
    } else {
      clientX = evt.clientX;
      clientY = evt.clientY;
    }

    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top)  * scaleY
    };
  }

  /* ---------------- DRAG ---------------- */
  function startDrag(evt) {
    const pos = getPos(evt);

    if (insideCircle(pos.x, pos.y, yellowToken)) {
      dragging = "yellow";
      anyDrag = true;
      draggedYellow = true;
    }
    else if (insideCircle(pos.x, pos.y, redToken)) {
      dragging = "red";
      anyDrag = true;
      draggedRed = true;
    }
    else dragging = null;
  }

  function drag(evt) {
    if (!dragging) return;
    evt.preventDefault();

    const pos = getPos(evt);

    if (dragging === "yellow") {
      yellowToken.x = pos.x;
      yellowToken.y = pos.y;
      handleCollisionYellowPushRed();
    } else if (dragging === "red") {
      redToken.x = pos.x;
      redToken.y = pos.y;
      handleCollisionRedPushYellow();
    }

    drawScene();
  }

  function stopDrag() { dragging = null; }

  /* ---------------- AUDIO ---------------- */
  function playFrase() {
    audioFrase.currentTime = 0;
    audioFrase.play().catch(() => {});
  }

  window.onload = () => {
    drawScene();
    playFrase();
  };

  /* ---------------- SALVATAGGIO ---------------- */
  function salvaRispostaTerapeuta(dati) {
    const key = "risposte_sessione";
    const esistenti = JSON.parse(localStorage.getItem(key) || "[]");

    esistenti.push({
      esercizio: "Frase finale 16",
      categoria: "Frasi finali",
      stimolo: "Usa il cerchio giallo per spostare il cerchio rosso",
      ha_risposto: dati.ha_risposto,
      risposta_grezza: dati.risposta_grezza,
      descrizione_risposta: dati.descrizione_risposta,
      corretta: dati.corretta,
      punteggio: dati.punteggio,
      ripetizioni_audio: 0,
      timestamp: new Date().toISOString()
    });

    localStorage.setItem(key, JSON.stringify(esistenti));
  }

  function valutaESalva() {
    let corretta        = false;
    let punteggio       = 0;
    let rispostaGrezza  = "";
    let descrizioneResp = "";
    let haRispostoFlag  = anyDrag;

    const gialloSiEMosso =
      yellowToken.x !== startYellow.x || yellowToken.y !== startYellow.y;

    const rossoSiEMosso =
      redToken.x !== startRed.x || redToken.y !== startRed.y;

    if (!anyDrag) {
      corretta        = null;
      punteggio       = 0;
      rispostaGrezza  = "nessun movimento";
      descrizioneResp = "Non ha mosso nessun gettone";
    }
    else if (collisionByYellow) {
      corretta        = true;
      punteggio       = 1;
      rispostaGrezza  = "giallo sposta rosso";
      descrizioneResp = "Ha usato il cerchio giallo per spostare il cerchio rosso";
    }
    else if (draggedRed && gialloSiEMosso) {
      corretta        = false;
      punteggio       = 0;
      rispostaGrezza  = "rosso sposta giallo";
      descrizioneResp = "Ha usato il cerchio rosso per spostare il cerchio giallo";
    }
    else if (
      (draggedYellow && !rossoSiEMosso) ||
      (draggedRed && !gialloSiEMosso)
    ) {
      corretta        = false;
      punteggio       = 0;
      rispostaGrezza  = "un gettone senza spostare l'altro";
      descrizioneResp = "Ha spostato un gettone senza far spostare l’altro";
    }
    else {
      corretta        = false;
      punteggio       = 0;
      rispostaGrezza  = "movimento non corretto";
      descrizioneResp = "Ha mosso i gettoni senza rispettare la consegna";
    }

    salvaRispostaTerapeuta({
      ha_risposto: haRispostoFlag,
      risposta_grezza: rispostaGrezza,
      descrizione_risposta: descrizioneResp,
      corretta: corretta,
      punteggio: punteggio
    });
  }

  nextBtn.onclick = () => {
    valutaESalva();
    location.href = "index.html";
  };

  /* ---------------- EVENTI ---------------- */
  canvas.addEventListener("mousedown", startDrag);
  canvas.addEventListener("mousemove", drag);
  window.addEventListener("mouseup", stopDrag);

  canvas.addEventListener("touchstart", startDrag, { passive: false });
  canvas.addEventListener("touchmove",  drag,      { passive: false });
  canvas.addEventListener("touchend",   stopDrag);
  canvas.addEventListener("touchcancel",stopDrag);

  drawScene();
</script>

</body>
</html>




